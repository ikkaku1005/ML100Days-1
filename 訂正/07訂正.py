#1. 請比較對一個 100 x 100 x 100 的陣列，使用不同方法對每一個元素 +1 的時間比較。
import numpy as np
Z = np.random.randint(0,100,1000000).reshape(100,100,100)
%timeit -n 10 a = 2
for i in Z:
    for j in i:
        for k in j:
            i = i + 1

%timeit -n 10 a = 2
for i in Z.flat:
    i = i+1

%timeit -n 10 a = 2
for i in np.nditer(Z): #迭帶
    i = i + 1

# Q: 請問i += 1 和 i = i + 1 兩者有什麼差異導致最後運算結果不同?
#概念上:
#one. a += b :直接改變該變數，會先調用 python 中的 iadd 方法，若沒有此方法，就調用 add 方法。
#two. a = a + b : 另外設一個變數(此為概念上來說，以這裡為例，雖然變數名稱都叫做 a)，並賦予值 (較直觀的)。
#應用上:
#先稍微了解 python 中的可變與不可變物件，
#不可變物件 : 數值型別(int、float)、字串(str)、元組(tule)
#可變物件 : 列表(list)、字典(dict)、集合(set)
#補充
#不可變物件，該物件所指向的記憶體中的值不能被改變。當改變某個變數時候，由於其所指的值不能被改變，相當於把原來的值複製一份後再改變，這會開闢一個新的地址，變數再指向這個新的地址。
#可變物件，該物件所指向的記憶體中的值可以被改變。變數（準確的說是引用）改變後，實際上是其所指的值直接發生改變，並沒有發生複製行為，也沒有開闢新的出地址，通俗點說就是原地改變。

#!重點來了!
#不可變物件沒有 iadd 方法，所以「在操作可變物件，其實用 one 或 two 結果是一樣的 (都調用 add 方法)。
#所以可變物件使用這兩種指令做的事情就「不一樣」摟。
#測試指令:
#a = [1,2,3,4]
#a +=(1,) #輸出 : [1,2,3,4,1]
#a = a + 1 # 輸出 : TypeError:  can only concatenate list (not "tuple") to list